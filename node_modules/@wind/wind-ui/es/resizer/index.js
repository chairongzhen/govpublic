function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

import React from 'react';
import classnames from 'classnames';
import { DraggableCore } from 'react-draggable';
import Icon from './icon';
var prefixCls = 'w-resizer'; // 似乎可以被react-draggable-transparent-selection取代
// const classDraggingSibling = `${prefixCls}-dragging-sibling`;// 'react-draggable-dragging-sibling';

var classResizerSibling = "".concat(prefixCls, "-sibling");
var placeholderId = "__".concat(prefixCls, "-placeholder");

function addClass(dom, className) {
  if (dom && dom.classList && dom.classList.add) {
    dom.classList.add(className);
  }
} // function removeClass(dom: HTMLElement, className: string) {
//   if (dom && dom.classList && dom.classList.remove) {
//     dom.classList.remove(className);
//   }
// }


function showPlaceholder(node, _ref) {
  var direction = _ref.direction;
  var el = document.getElementById(placeholderId);

  if (el == null) {
    el = document.createElement('div');
    el.setAttribute('id', placeholderId);
    el.setAttribute('class', "".concat(prefixCls, "-placeholder"));
    document.body.appendChild(el);
  }

  var _node$getBoundingClie = node.getBoundingClientRect(),
      height = _node$getBoundingClie.height,
      width = _node$getBoundingClie.width,
      top = _node$getBoundingClie.top,
      left = _node$getBoundingClie.left; // console.log('showPlaceholder',height, width,direction);


  if (direction === 'n' || direction === 's') {
    el.style.width = "".concat(width, "px");
    el.style.height = '';
  } else {
    el.style.height = "".concat(height, "px");
    el.style.width = '';
  }

  el.style.top = "".concat(top, "px");
  el.style.left = "".concat(left, "px");
  el.style.transform = '';
  el.style.display = "block";
}

function dragPlaceHolder(_ref2) {
  var deltaX = _ref2.deltaX,
      deltaY = _ref2.deltaY;
  // console.log('dragPlaceHolder',{ deltaX, deltaY });
  var el = document.getElementById(placeholderId);

  if (el != null) {
    var transform = "translateX(".concat(deltaX || 0, "px)  translateY(").concat(deltaY || 0, "px)");
    el.style.transform = transform;
  }
}

function hidePlaceholder() {
  var el = document.getElementById(placeholderId);

  if (el != null) {
    el.style.display = 'none';
  }
}

var Resizer = /*#__PURE__*/function (_React$Component) {
  _inherits(Resizer, _React$Component);

  var _super = _createSuper(Resizer);

  function Resizer(props) {
    var _this;

    _classCallCheck(this, Resizer);

    _this = _super.call(this, props);

    _this.saveRef = function (node) {
      _this.node = node;
    };

    _this.handleStart = function (_e, data) {
      // console.log('handleStart', data);
      var node = data.node;
      var direction = _this.props.direction;
      var foldedSize = _this.state.foldedSize;
      _this.startData = data;
      var preNode = node.previousElementSibling;
      var nextNode = node.nextElementSibling; // if (preNode && nextNode) {
      //   preNode.className += ` ${classDraggingSibling}`;
      //   nextNode.className += ` ${classDraggingSibling}`;
      // }

      if (preNode && nextNode) {
        if (direction === 'n' || direction === 's') {
          _this.min = -(preNode.getBoundingClientRect().height - foldedSize);
          _this.max = nextNode.getBoundingClientRect().height;
        } else {
          _this.min = -(preNode.getBoundingClientRect().width - foldedSize);
          _this.max = nextNode.getBoundingClientRect().width;
        }
      }

      _this.delta = null;
    };

    _this.handleStop = function (e, data) {
      // console.log('handleStop', e, data);// data.deltaX  无效
      var node = data.node;

      var _assertThisInitialize = _assertThisInitialized(_this),
          delta = _assertThisInitialize.delta;

      var preNode = node.previousElementSibling;
      var nextNode = node.nextElementSibling;
      var _this$props = _this.props,
          direction = _this$props.direction,
          onResize = _this$props.onResize;
      var folded = _this.state.folded;
      var autoResize = true,
          styleName = 'width',
          preSize,
          nextSize; // console.log('handleStop', delta);

      _this.start = false; // removeClass(document.body, `${prefixCls}-body-dragging-${direction}`);

      document.body.classList.remove("".concat(prefixCls, "-body-dragging"), "".concat(prefixCls, "-body-dragging-").concat(direction));
      hidePlaceholder();

      if (delta == null) {
        return; // 未移动
      }

      var button = node.querySelector(".".concat(prefixCls, "-button"));

      if (button && button.contains(e.target)) {
        return; //  避免点击button引起的handleStop
      }

      var _delta$deltaX = delta.deltaX,
          deltaX = _delta$deltaX === void 0 ? 0 : _delta$deltaX,
          _delta$deltaY = delta.deltaY,
          deltaY = _delta$deltaY === void 0 ? 0 : _delta$deltaY;

      if (preNode && nextNode) {
        // preNode.className = preNode.className.replace(` ${classDraggingSibling}`, '');
        // nextNode.className = nextNode.className.replace(` ${classDraggingSibling}`, '');
        if (direction === 'n' || direction === 's') {
          var h = preNode.getBoundingClientRect().height;
          var h2 = nextNode.getBoundingClientRect().height; // deltaY = data.y - startData.y;
          // y = data.y;
          // lastY = startData.y;

          preSize = h + deltaY;
          nextSize = h2 - deltaY;
          styleName = 'height';
        } else {
          var w = preNode.getBoundingClientRect().width;
          var w2 = nextNode.getBoundingClientRect().width; // deltaX = data.x - startData.x;
          // x = data.x;
          // lastX = startData.x;

          preSize = w + deltaX;
          nextSize = w2 - deltaX;
        }

        if (folded && (deltaX > 0 || deltaY > 0)) {
          folded = false;

          _this.setState({
            folded: folded
          });
        }

        if (typeof onResize === 'function') {
          autoResize = onResize(e, {
            node: node,
            deltaX: deltaX,
            deltaY: deltaY,
            folded: folded
          }) !== false;
        }

        if (autoResize) {
          preNode.style[styleName] = "".concat(preSize, "px");
          nextNode.style[styleName] = "".concat(nextSize, "px");
        }
      }
    };

    _this.handleDrag = function (_e, data) {
      var node = data.node;
      var direction = _this.props.direction;

      var _assertThisInitialize2 = _assertThisInitialized(_this),
          startData = _assertThisInitialize2.startData,
          min = _assertThisInitialize2.min,
          max = _assertThisInitialize2.max;

      if (!_this.start) {
        _this.start = true;
        document.body.classList.add("".concat(prefixCls, "-body-dragging"), "".concat(prefixCls, "-body-dragging-").concat(direction));
        showPlaceholder(node, {
          direction: direction
        });
      } // console.log('handleDrag', data);
      // todo: 移动到接近folded大小时自动切换folded状态功能


      if (direction === 'n' || direction === 's') {
        _this.delta = {
          deltaY: Math.min(Math.max(data.y - startData.y, min), max)
        };
        dragPlaceHolder(_this.delta);
      } else {
        _this.delta = {
          deltaX: Math.min(Math.max(data.x - startData.x, min), max)
        };
        dragPlaceHolder(_this.delta);
      }
    };

    _this.handleToogle = function (e) {
      // console.log('handleToogle');
      var _assertThisInitialize3 = _assertThisInitialized(_this),
          node = _assertThisInitialize3.node;

      var _this$props2 = _this.props,
          direction = _this$props2.direction,
          onResize = _this$props2.onResize;
      var _this$state = _this.state,
          folded = _this$state.folded,
          foldedSize = _this$state.foldedSize;
      var preNode = node.previousElementSibling;
      var nextNode = node.nextElementSibling;
      var autoResize = true;
      var deltaX = 0,
          deltaY = 0,
          preSize,
          nextSize,
          styleName = 'width';

      if (preNode && nextNode) {
        switch (direction) {
          case 'n':
            styleName = 'height';

            if (folded) {
              deltaY = -_this.toogleSize + foldedSize;
              preSize = _this.toogleSize;
              nextSize = nextNode.getBoundingClientRect().height + deltaY;
            } else {
              _this.toogleSize = preNode.getBoundingClientRect().height;
              deltaY = -_this.toogleSize + foldedSize;
              preSize = foldedSize;
              nextSize = nextNode.getBoundingClientRect().height - deltaY;
            }

            break;

          case 's':
            styleName = 'height';

            if (folded) {
              deltaY = -_this.toogleSize + foldedSize;
              preSize = preNode.getBoundingClientRect().height + deltaY;
              nextSize = _this.toogleSize;
            } else {
              _this.toogleSize = nextNode.getBoundingClientRect().height;
              deltaY = -(_this.toogleSize - foldedSize);
              preSize = preNode.getBoundingClientRect().height + deltaY;
              nextSize = foldedSize;
            }

            break;

          case 'w':
            if (folded) {
              deltaX = _this.toogleSize - foldedSize;
              preSize = _this.toogleSize;
              nextSize = nextNode.getBoundingClientRect().width - deltaX;
            } else {
              _this.toogleSize = preNode.getBoundingClientRect().width;
              deltaX = -_this.toogleSize + foldedSize;
              preSize = foldedSize;
              nextSize = nextNode.getBoundingClientRect().width - deltaX;
            }

            break;

          case 'e':
            if (folded) {
              deltaX = -_this.toogleSize + foldedSize;
              preSize = preNode.getBoundingClientRect().width + deltaX;
              nextSize = _this.toogleSize;
            } else {
              _this.toogleSize = nextNode.getBoundingClientRect().width;
              deltaX = _this.toogleSize - foldedSize;
              preSize = preNode.getBoundingClientRect().width + deltaX;
              nextSize = foldedSize;
            }

            break;

          default:
            break;
        } // console.log(this.toogleSize, { direction, folded, deltaX, foldedSize, preSize, nextSize, preNode, nextNode });


        folded = !folded;

        _this.setState({
          folded: folded
        });

        if (typeof onResize === 'function') {
          // onResize 返回 false 可阻止内部Resize执行
          autoResize = onResize(e, {
            node: node,
            deltaX: deltaX,
            deltaY: deltaY,
            folded: folded
          }) !== false;
        }

        if (autoResize && preSize != null && nextSize != null) {
          preNode.style[styleName] = "".concat(preSize, "px");
          nextNode.style[styleName] = "".concat(nextSize, "px");
        }
      }
    };

    _this.state = {
      folded: props.defaultFolded,
      foldedSize: props.foldedSize,
      unfoldedSize: props.unfoldedSize
    };
    _this.toogleSize = props.unfoldedSize || 0;
    return _this;
  }

  _createClass(Resizer, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var node = this.node;

      if (node) {
        // 若相邻组件因重新render刷新className导致样式丢失，只能手动给组件添加上此样式(Resizer.SiblingClassName)
        if (node.previousElementSibling) {
          addClass(node.previousElementSibling, classResizerSibling);
        }

        if (node.nextElementSibling) {
          addClass(node.nextElementSibling, classResizerSibling);
        }
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _classnames;

      // console.log('ResizeHandle render');
      var folded = this.state.folded;
      var _this$props3 = this.props,
          direction = _this$props3.direction,
          foldable = _this$props3.foldable,
          style = _this$props3.style,
          theme = _this$props3.theme,
          className = _this$props3.className,
          type = _this$props3.type;
      var toogleDir = direction;

      if (folded) {
        switch (direction) {
          case 'n':
            toogleDir = 's';
            break;

          case 's':
            toogleDir = 'n';
            break;

          case 'w':
            toogleDir = 'e';
            break;

          case 'e':
            toogleDir = 'w';
            break;

          default:
            break;
        }
      }

      return /*#__PURE__*/React.createElement(DraggableCore // axis={(direction === 'n' || direction === 's') ? 'y' : 'x'}
      , {
        onStart: this.handleStart,
        onDrag: this.handleDrag,
        onStop: this.handleStop
      }, /*#__PURE__*/React.createElement("div", {
        ref: this.saveRef,
        className: classnames(className, prefixCls, (_classnames = {}, _defineProperty(_classnames, "".concat(prefixCls, "-folded"), folded), _defineProperty(_classnames, "".concat(prefixCls, "-").concat(direction), true), _defineProperty(_classnames, "".concat(prefixCls, "-").concat(theme), true), _defineProperty(_classnames, "".concat(prefixCls, "-type-").concat(type), type != null), _classnames)),
        style: style
      }, foldable ? /*#__PURE__*/React.createElement("span", {
        onClick: this.handleToogle,
        className: "".concat(prefixCls, "-button ").concat(prefixCls, "-button-").concat(toogleDir)
      }, /*#__PURE__*/React.createElement(Icon, {
        type: "button-bg"
      })) : null));
    }
  }]);

  return Resizer;
}(React.Component); // static propTypes = {
//   type: PropTypes.string,
//   direction: PropTypes.string, // n/s/w/e
//   theme: PropTypes.string,
//   position: PropTypes.string,
//   foldable: PropTypes.bool,
//   defaultFolded: PropTypes.bool,
//   foldedSize: PropTypes.number,
//   unfoldedSize: PropTypes.number,
//   onResize: PropTypes.func,
// }


Resizer.SiblingClassName = classResizerSibling;
Resizer.defaultProps = {
  type: 'default',
  direction: 'w',
  theme: 'light',
  // position: 'default', // 其实没有必要
  foldable: true,
  defaultFolded: false,
  foldedSize: 0,
  unfoldedSize: 208
};
export default Resizer;
//# sourceMappingURL=index.js.map
